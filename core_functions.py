"""
SQL agent core functions

This code comes from an initial work done by A. Panda, then I have have added
several contributions to help increase accuracy.
Today the most important code is encapsulated in ai_sql_agent
Here we have only utility functions
"""

import re

from langchain.prompts import PromptTemplate

from prompt_template import REPHRASE_PROMPT, PROMPT_CORRECTION_TEMPLATE
from utils import get_console_logger
from config import DEBUG

logger = get_console_logger()


def clean_schema(schema: str) -> str:
    """
    remove some not needed part from the schema description, to mak it shorter
    """
    # Step 2: Remove lines like COMPRESS FOR QUERY HIGH ROW LEVEL LOCKING
    # Regex pattern matches the entire line with "COMPRESS FOR QUERY HIGH ROW LEVEL LOCKING"
    cleaned_schema = re.sub(
        r"^\s*COMPRESS FOR QUERY HIGH ROW LEVEL LOCKING\s*$",
        "",
        schema,
        flags=re.MULTILINE,
    )

    # Return the cleaned schema without extra spaces or lines
    return cleaned_schema.strip()


def extract_sql_from_response(response_text):
    """
    Extract the SQL query from the LLM-generated response.
    Args:
        response_text (str): Text generated by the LLM.
    Returns:
        str: Extracted SQL query or None if not found.
    """
    if DEBUG:
        logger.info(" Inside extract_sql_from_response")
        logger.info(response_text)

    # assume sql enclosed in triple backtick
    sql_match = re.search(r"```(.*?)```", response_text, re.DOTALL)

    if sql_match:
        return sql_match.group(1).strip()
    return None


def extract_plot_code_from_response(response_text):
    """
    Extract the plot code from the LLM-generated response.
    Args:
        response_text (str): Text generated by the LLM.
    Returns:
        str: Extracted plot code or None if not found.
    """
    if DEBUG:
        logger.info(" Inside extract_plot_code_from_response")
        logger.info(response_text)

    # assume sql enclosed in triple backtick
    plot_code = re.search(r"```(.*?)```", response_text, re.DOTALL)

    if plot_code:
        plot_code = plot_code.group(1).strip()
        # Remove the first line
        lines = plot_code.splitlines()

        # If the first line contains "python", remove it
        if lines[0].strip().lower() == "python":
            lines = lines[1:]

        # Join the remaining lines back into a single text
        plot_code = "\n".join(lines)

        if DEBUG:
            logger.info("")
            logger.info("Extracted plotting code:")
            logger.info(plot_code)

        return plot_code

    return None


def explain_response(user_request, rows, llm):
    """
    Explain the data retrieved using a language model.
    Args:
        user_request (str): The original request.
        rows: data in rows, returned from the SQL query
        llm: Language model instance.
    Returns:
        str: explanation.
    """
    rephrase_prompt = PromptTemplate(
        template=REPHRASE_PROMPT, input_variables=["user_request", "data"]
    )
    rephrase_chain = rephrase_prompt | llm

    result = rephrase_chain.invoke({"user_request": user_request, "data": rows})

    return result.content


def remove_sql_prefix(input_text):
    """
    Remove 'sql' prefix from the beginning of the SQL query, if present.
    Args:
        input_text (str): The original SQL query.
    Returns:
        str: Cleaned SQL query without the 'sql' prefix.
    """
    stripped_text = input_text.lstrip()

    # Check if the string starts with "sql" and remove it
    if stripped_text.startswith("sql"):
        return stripped_text[4:].lstrip()
    # else
    return stripped_text


def clean_sql_query(sql_query):
    """
    Post-process the SQL query to make it Oracle-compatible.
    Args:
        sql_query (str): The original SQL query.
    Returns:
        str: Cleaned and processed SQL query.
    """
    # remove ;
    # changed: don't remove \n anymore
    cleaned_query = sql_query.strip().rstrip(";")

    # remove "sql" for Cohere
    return remove_sql_prefix(cleaned_query)
