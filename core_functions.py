"""
SQL agent core functions

This code comes from an initial work done by A. Panda, then we have added
several contributions to help increase accuracy
"""

import re

from langchain_community.utilities.sql_database import SQLDatabase
from langchain_community.agent_toolkits import SQLDatabaseToolkit
from langchain.prompts import PromptTemplate


from prompt_template import REPHRASE_PROMPT, PROMPT_CORRECTION_TEMPLATE
from utils import get_console_logger
from config import VERBOSE, DEBUG

logger = get_console_logger()


def format_schema(schema):
    """
    Format the schema information for better readability.
    Args:
        schema (dict): Raw schema information.
    Returns:
        str: Formatted schema string.
    """
    # Split the schema by the CREATE TABLE keyword to separate each table
    tables = schema["table_info"].split("CREATE TABLE")

    # Reconstruct the schema with better formatting
    formatted_schema = []
    for table in tables:
        if table.strip():  # Check if the table is not an empty string
            formatted_schema.append(f"CREATE TABLE {table.strip()}\n{'-'*40}\n")

            if DEBUG:
                logger.info("Table: %s", table.strip())

    if VERBOSE:
        logger.info("")
        logger.info("Found information for %s tables...", len(tables))
        logger.info("")

    return "\n".join(formatted_schema)


def clean_schema(schema: str) -> str:
    """
    remove some not needed part from the schema description, to mak it shorter
    """
    # Step 2: Remove lines like COMPRESS FOR QUERY HIGH ROW LEVEL LOCKING
    # Regex pattern matches the entire line with "COMPRESS FOR QUERY HIGH ROW LEVEL LOCKING"
    cleaned_schema = re.sub(
        r"^\s*COMPRESS FOR QUERY HIGH ROW LEVEL LOCKING\s*$",
        "",
        schema,
        flags=re.MULTILINE,
    )

    # Return the cleaned schema without extra spaces or lines
    return cleaned_schema.strip()


def get_formatted_schema(engine, llm):
    """
    Fetch and format the schema information from the database.
    Args:
        engine (Engine): SQLAlchemy engine instance.
        llm: Language model instance.
    Returns:
        str: Formatted schema string.
    """
    logger.info("Getting schema information...")

    try:
        toolkit = SQLDatabaseToolkit(db=SQLDatabase(engine), llm=llm)

        raw_schema = toolkit.get_context()

        if DEBUG:
            logger.info(raw_schema)

        schema = format_schema(raw_schema)

        # added to reduce schema size, remove
        # last line (compress for) in create table
        schema = clean_schema(schema)

        return schema
    except Exception as e:
        logger.error("Error fetching or formatting schema: %s", e, exc_info=True)
        return ""


def extract_sql_from_response(response_text):
    """
    Extract the SQL query from the LLM-generated response.
    Args:
        response_text (str): Text generated by the LLM.
    Returns:
        str: Extracted SQL query or None if not found.
    """
    if DEBUG:
        logger.info(" Inside extract_sql_from_response")
        logger.info(response_text)

    # assume sql enclosed in triple backtick
    sql_match = re.search(r"```(.*?)```", response_text, re.DOTALL)

    if sql_match:
        return sql_match.group(1).strip()
    return None


def extract_plot_code_from_response(response_text):
    """
    Extract the plot code from the LLM-generated response.
    Args:
        response_text (str): Text generated by the LLM.
    Returns:
        str: Extracted plot code or None if not found.
    """
    if DEBUG:
        logger.info(" Inside extract_plot_code_from_response")
        logger.info(response_text)

    # assume sql enclosed in triple backtick
    plot_code = re.search(r"```(.*?)```", response_text, re.DOTALL)

    if plot_code:
        plot_code = plot_code.group(1).strip()
        # Remove the first line
        lines = plot_code.splitlines()

        # If the first line contains "python", remove it
        if lines[0].strip().lower() == "python":
            lines = lines[1:]

        # Join the remaining lines back into a single text
        plot_code = "\n".join(lines)

        if DEBUG:
            logger.info("")
            logger.info("Extracted plotting code:")
            logger.info(plot_code)

        return plot_code

    return None


def explain_response(user_request, rows, llm):
    """
    Explain the data retrieved using a language model.
    Args:
        user_request (str): The original request.
        rows: data in rows, returned from the SQL query
        llm: Language model instance.
    Returns:
        str: explanation.
    """
    rephrase_prompt = PromptTemplate(
        template=REPHRASE_PROMPT, input_variables=["user_request", "data"]
    )
    rephrase_chain = rephrase_prompt | llm

    result = rephrase_chain.invoke({"user_request": user_request, "data": rows})

    return result.content


def remove_sql_prefix(input_text):
    """
    Remove 'sql' prefix from the beginning of the SQL query, if present.
    Args:
        input_text (str): The original SQL query.
    Returns:
        str: Cleaned SQL query without the 'sql' prefix.
    """
    stripped_text = input_text.lstrip()

    # Check if the string starts with "sql" and remove it
    if stripped_text.startswith("sql"):
        return stripped_text[4:].lstrip()
    # else
    return stripped_text


def clean_sql_query(sql_query):
    """
    Post-process the SQL query to make it Oracle-compatible.
    Args:
        sql_query (str): The original SQL query.
    Returns:
        str: Cleaned and processed SQL query.
    """
    # remove ;
    # changed: don't remove \n anymore
    cleaned_query = sql_query.strip().rstrip(";")

    # remove "sql" for Cohere
    return remove_sql_prefix(cleaned_query)


def generate_sql_with_models(
    user_query, schema, db_manager, llm_manager, prompt_template, user_group_id=None
):
    """
    Combine SQL generation and post-processing.
    Use a list of models... if with the first get error then try with second
    and so on until one succeed
    Args:
        user_query (str): User-provided query.
        schema (str): Formatted schema information.
        engine: used to test the sintax of the generated query
        llm_list: Language model list
    Returns:
        str: Cleaned SQL query, empty if wrong
    """
    for llm in llm_manager.llm_models:
        sql_query, _ = llm_manager.generate_sql(
            user_query, schema, llm, prompt_template, user_group_id
        )

        if sql_query:
            cleaned_query = clean_sql_query(sql_query)
            if db_manager.test_query_syntax(cleaned_query):
                return cleaned_query  # Return on first success

        # if here the previous showed errors
        logger.info("Trying with another model...")

    logger.error("All models failed to generate a valid SQL query.")
    logger.info("User query: %s", user_query)

    return ""


def correct_sql_query(user_query, schema, sql_and_error, llm):
    """
    Correct a SQL query with errors.
    This function can be used as a second try if first gives error.

    To be tested
    """
    prompt = PromptTemplate(
        template=PROMPT_CORRECTION_TEMPLATE,
        input_variables=["schema", "query", "sql_and_error"],
    )
    llm_chain = prompt | llm

    try:
        response = llm_chain.invoke(
            {"schema": schema, "query": user_query, "sql_and_error": sql_and_error}
        )
        corrected_sql_query = extract_sql_from_response(response.content)

        cleaned_query = clean_sql_query(corrected_sql_query)
    except Exception as e:
        logger.error("Error in correct_sql: %s", e)
        cleaned_query = ""

    return cleaned_query, response.content
